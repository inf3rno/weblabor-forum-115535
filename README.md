# weblabor-forum-115535

On [weblabor.hu](http://weblabor.hu) in 2013 we had an [argument](http://weblabor.hu/forumok/temak/115535#comment-97139) with [Hidvégi Gábor](http://weblabor.hu/tagok/2215) in the forum topic [#115535](http://weblabor.hu/forumok/temak/115535). The whole is on Hungarian, so if that's is not your native language or you are not a language geek, you don't need to read it, I write here a short summary. Gábor claimed (and he probably still believe), that procedural or structured programming (they are almost the same style) are superior to object-oriented programming by almost all of the web applications, because by them code does not reach the complexity, by which object-oriented programming is easier and safer to use than procedural/structured programming. I did not agree, so I felt the need to examine this in detail and find some evidence for the opposite.

I implemented the same small PHP project in 4 different styles to have some facts. All the project does is basic authentication, profile page, password change, so nothing complicated. According to my [comments](http://weblabor.hu/forumok/temak/115535#comment-97249) the *structured* implementation was working after 5 hours and it took about 10 hours to refactor it to *object-oriented* without tests. I had 2 options to write tests: I could override global variables to create fixtures, or I could write e2e tests. I did not bother with any of them, with this size of project concentration on not to make mistakes was enough. After I was complete with the refactoring, I started the project again from scratch using test-driven development (aka. TDD). I used `... -> user story -> test -> implementation -> refactoring -> ...` small development cycles. With that everything went smoothly, and I did not need to spend time with debugging or thinking over the project structure, like I had to by *refactoring the structured* code. The *structured* and *refactored OO* code has 0% test coverage, while the other ones have 100% coverage only by the HTTP framework part and 0% by the application part. I did not feel the need to write e2e and integration tests for the application, because the project was so simple. I extracted a HTTP framework from the *OO + TDD* code, which I moved to the `./Core/` directory. I imported this HTTP framework in the *OO + TDD + framework* style. Even by this small size of project I felt by the *structured* code the more lines I write the more inconvenient it gets. The *object-oriented with TDD* was the complete opposite, it was hard to begin with, but after a while things were getting faster, because all I did was reusing the code of the HTTP Framework. I applied the SRP (which is natural by TDD), so I did not have to think over the classes and methods, like I did by *refactoring the structured* style. The *object-oriented with framework* was way too easy compared to the others, since most of the code already existed in the framework, all I had to do is use it.

I measured the development times by checking the commit timestamps and the punch cards on GitHub. I did not measure the performance, all of them was fast enough, so I did not feel the need. I measured the code lines with notepad++ simply counting the `\n`-s in the project files. I got the KB values from Windows Explorer, so I used nothing special. Here are the results:

| Coding Style | Structured (or Procedural) | Object-Oriented refactored from Structured | Object-Oriented with TDD | Object-Oriented using a Framework |
| --- | --- | --- | --- | --- |
| repo | [link](https://github.com/inf3rno/weblabor-forum-115535-strukturalt) | [link](https://github.com/inf3rno/weblabor-forum-115535-strukturalt/tree/dd249eaef949a97c7ad7b3deb06e4e428ce37569) | [link](https://github.com/inf3rno/weblabor-forum-115535-tdd) | [link](https://github.com/inf3rno/weblabor-forum-115535-framework) |
| begin | Mar 24 00:11 | Mar 24 04:51 | Mar 25 04:20 | | Mar 27 07:36 |
| end | Mar 24 04:51 | Mar 24 15:01 | Mar 26 13:41 | Mar 27 09:30 |
| development time | 04:40 | 10:10 | 16:43 | 01:56 |
| commits | 17 | 32 | 80 | 10 |
| |
| project files | 14 | 29 | 63 | 64 |
| written code files | 14 | 18 | 63 | 21 |
| written app files | 14 | 18 | 44 | 21 |
| written test files |  |  | 19 |  |
| imported app files |  |  |  | 24 |
| imported test files |  |  |  | 19 |
| |
| project size | 4.7 KB | 14.9 KB | 32.9 KB | 35.6 KB |
| written code size | 4.7 KB | 10.2 KB | 32.9 KB | 13.9 KB |
| written app size | 4.7 KB | 10.2 KB | 19.4 KB | 13.9 KB |
| written test size |  |  | 13.4 KB |  |
| imported app size |  | 4.7 KB |  | 8.2 KB |
| imported test size |  |  |  | 13.4 KB |
| |
| project lines | 231 | 673 | 1386 | 1475 |
| written code lines | 231 | 442 | 1386 | 562 |
| written app lines | 231 | 442 | 872 | 562 |
| written test lines |  |  | 514 |  |
| imported app lines |  | 231 |  | 399 |
| imported test lines |  |  |  | 514 |
| |
| development speed size/hours | 1.0 KB/h | 1.0 KB/h | 2.0 KB/h | 7.2 KB/h |
| development speed lines/hours | 49 L/h | 43 L/h | 83 L/h | 291 L/h |

According to this statistics, the development speed was about 43-49 L/h by writing or refactoring code without tests. I don't think this would change by adding test for procedural code, because by TDD refactoring means refactoring the tests as well. Probably by writing e2e tests with BDD would be the best solution if you want to have a stable code, but ofc. you won't be able to have complete coverage, because e2e tests are on the top of the testing pyramid. Compared to this 43-39 L/h, the test-driven developed object-oriented code was 83 L/h and the object-oriented code with framework was 291 L/h. By coding the test-driven developed object-oriented code I felt the beginning almost slower than developing the structured code, but after the code base of the framework increased, it was getting more and more easier, because I had more code to reuse. The structured code was the opposite it required more and more time to add new code while it was getting bigger, but I think this affected the development speed only slightly. Probably by bigger projects I would have had more problem because structured programming is not so good by handling complexity. At least not by PHP. Probably other languages can use functions in namespaces and they have data structures, so almost everything you need to write proper code. So this is surely not a representative statistics, and it is valid only by PHP. I measured the size and lines by the object-oriented with TDD style after the first day: 04:20-13:53 => 9.55h, 16.3 KB, 673 lines, which means 1.7 KB/h and 70 L/h in the first 10 hours of the project, while 2.3 KB/h and 99 L/s in the last 7 hours of the project. This confirms what I felt by the better development speed at the end of the project.

Let's compare the code size, which is probably in correlation with complexity (note, that I tried to use long descriptive names by the stuructured code as well). I'll use the written app size (except the refactored where I add the size of the structured code as well), since we usually don't care about the implementation of the framework, we just use it. By structured code the application size is 4.7 KB (231 lines in 14 files), by the refactored oo 14.9 KB (673 lines in 29 files), by the TDD 19.4 KB (872 lines in 44 files) and by the oo using framework 13.9 KB (562 lines in 21 files). Each of them does the same thing, so we can say, that the structured has a reference 1.0 code size and the others have ~3.1, ~4.0, ~2.7 size based on the KB and lines. So by code size (and probably complexity) the structured is the absolute winner. Even with the one with framework has more than double the size. Ofc. size is not everything, let's check code fragmentation with file and line sizes. By the structured the values are 17L/F and 21 B/L, by the refactored 23 L/F and 23 B/L, by the TDD 20 L/F and 23 B/L and by the one with framework 27 L/F and 25 B/L. So let's use the structured as 1.0 reference again: 1.3, 1.2 and 1.4 are the values. There is no big difference in this indicator and the structured is still the lowest one. So 

I summed up the conclusions at the end of the text:

 - By structural programming the low code reusability is a problem after you reach a certain level of complexity. Before that it has good development times. So if you have something really simple, which you can solve with 10 or less functions, then go on and use it. Otherwise I would recommend object-oriented programming with TDD, or BDD by more complex projects, because it increases test code reusability. It is ofc. possible to increase the reusability of structured code, you need to do something like object-oriented programming out of the box does: you have to bind your functions to data structures and apply something like the single responsibility principle. So the result will be inherently reusable, but if you want to do that, then you should check maybe working with objects instead of data structures would be beneficial.
 - By structural programming you will end up with shorter and simpler code. This can be a result of low reusability (extracting functions and variables always increases the code size) and the lack of meaningful function and variables names. On the other hand the same can mean, that the application is not overengineered. It is hard to decide based on the numbers, you have to read the code.
 - If we have a framework with a good API, which we can use intuitively, then the development speed can be 5-10 times better compared to writing everything from scratch, so it does worth the effort to learn the usage of a framework, if it is a good one. Even by structural/procedural programming, it is better to use an existing, well tested, production ready framework.
 - Refactoring spaghetti code does not worth the effort, even if we rewrite the complete code, it is much faster with a framework than refactoring the existing code, not to mention the complete lack of test coverage. If we count only with the application size by the TDD project and subtract the the estimated test writing time from the development time, then the pure app development time is 19.4 KB / 2.0 KB/h = 9.7h = 09:42, which is the same as the development time by refactoring the structured code 10:10. And that structured code was simple and well coded compared to the spaghetti code we usually meet. Do try to refactor it, it will break and you will suffer!
 - My conclusion about structured/procedural and object-oriented programming that it is much harder to make quality code with procedural programming. It is not impossible, but you need more experience with it. Most of the web developers, who use it, do not have the skills necessary to use it properly. The other ones, which have the skills, won't use it for web development especially not by big projects, if they can use oop, since oop is for describing higher abstraction level concepts, while structured/procedural programming are more about lower abstraction level problems, which are much closer to the hardware. So I won't recommend structured/procedural programming by developing webapplications, especially not in PHP, which poorly supports these styles.
